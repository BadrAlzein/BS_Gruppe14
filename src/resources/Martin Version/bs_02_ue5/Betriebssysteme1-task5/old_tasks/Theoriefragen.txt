Was ist präemptives Scheduling und wie kann es realisiert werden?

Ein präemptives Verfahren kann dem Prozess Ressourcen bereits vor der Fertigstellung wieder entziehen, um sie zwischenzeitlich anderen Prozessen zuzuteilen. Der Prozess wird dabei in seiner Ausführung unterbrochen (er geht in den Zustand ‚bereit‘ über) und verharrt dort, bis ihm durch den Scheduler erneut Ressourcen zugeteilt werden.

Beispiel für präemptives Schduling: ein Prozess mit niedriger Priorität kann ewig auf
CPU-Zuteilung warten, da ständig hochprioritäre Prozesse die CPU anfordern.

- Zuerst in Anwendung, dann Timer-Interrupt
- möchten runter ins Betriebssystem, müssen mithilfe vom Guardian zur "Gate" gelangen
- können dann in den BS-Modus wechseln
- Handle() Methode wird aufgerufen, kommen zu den Gerätetreiber -> reschedule -> Scheduler -> dispatch


-------------------------------------------------------------------------------------------------------------
Wie kann man eine quasiparallele Abarbeitung von Prozessen durch ein präemptives Scheduling
erreichen?

- konkretes Intervall (relativ klein) für die Unterbrechung
- 1 Prozess wird nur so lange ausgeführt, wie das Intervall lang ist
- Mensch hat die Annahme, dass Prozesse parallel laufen, weil Wechsel zwischen Prozessen sehr schnell


-------------------------------------------------------------------------------------------------------------
Was wäre ein passendes Beispiel für einen nebenläufigen Zugriff auf gemeinsame Daten?

- Kontoführung
- Prozess 1: Addieren von Guthaben
- Prozess 2: Abbuchen von Guthaben
- muss verzahnt ausgeführt werden, sonst Überlappungen -> Fehler
- Bsp.: 1
		2
	1
	1
		2
	1
- Zum Beispiel ein assert, dass vor jeder Abbuchung mindestens einmal das Konto mit einer positiven Änderung versehen werden muss, damit die min und max Schranken des Kontos eingehalten werden


-------------------------------------------------------------------------------------------------------------
Was ist ein Programmable Interval Timer?

- Taktintervall kann definiert werden
- bei jedem Takt ein Ausgabesignal

-------------------------------------------------------------------------------------------------------------
Wie funktioniert der Programmable Interval Timer (PIT)?

PITs können einmalig oder periodisch sein. One-Shot-Timer senden nur einmal ein Signal und hören dann auf zu zählen. Periodische Timer senden jedes Mal, wenn sie einen bestimmten Wert erreichen, und starten dann neu, wodurch ein Signal in periodischen Abständen erzeugt wird. Periodische Zeitgeber werden typischerweise verwendet, um Aktivitäten aufzurufen, die in regelmäßigen Abständen ausgeführt werden müssen.

Zähler werden in der Regel mit festen Intervallen programmiert, die bestimmen, wie lange der Zähler zählen soll, bevor er ein Ausgabesignal sendet. Das Intervall bestimmt, wie lange der Zähler zählen wird, bevor er ein Signal ausgibt.


-------------------------------------------------------------------------------------------------------------
Wie kann man diesen konfigurieren (Beschreibt eine Konfigurationssequenz!)?

PIT	Zähler	Nutzung
1	0	Periodische Unterbrechungen
1	1	Speicher-Refresh
1	2	Tonerzeugung
2	0	Fail-Safe-Timer (NMI)
2	1	Ungenutzt
2	2	Ungenutzt

Jeder PIT kann mit Hilfe von vier Ports angesprochen werden:(siehe Link)
Port(1.PIT)	Port(2.PIT)	Register	R/W
0x40		0x48		Zähler 0	R/W
0x41		0x49		Zähler 1	R/W
0x42		0x4a		Zähler 2	R/W
0x43		0x4b		Steuerregister	R

Alle Ports sind nur 8 Bits breit. Um 16 Bit Zählerwerte in den PIT zu bekommen wird eine besondere Technik benutzt. Zunächst muss dem PIT über ein Steuerwort mitgeteilt werden, was man überhaupt von ihm will. Das Steuerwort hat den folgenden Aufbau:

Bit(s)	Wert	Bedeutung
6-7	Zählerauswahl
	00	Zähler 0
	01	Zähler 1
	10	Zähler 2
	11	ungültig beim 8253, Read-Back-Befehl beim 8254
4-5	Lesen/Schreiben
	00	Zähler-Latch-Befehl
	01	nur niederwertiges Zählerbyte
	10	nur höherwertiges Zählerbyte
	11	niederwertiges, anschließend höherwertiges Zählerbyte
1-3	Modus 0 bis Modus 5
0	Zählformat
	0	binäre Zählung von 16 Bit
	1	Zählung mit vierstelligen BCD Zahlen

Der Zähler-Latch-Befehl und der Read-Back-Befehl sind nur für das Auslesen von Zählerwerten von Interesse. Daher wird hier nicht weiter darauf eingegangen.

Der Modus bestimmt, wie der Zähler arbeitet und ob er mit Hilfe der OUTx Leitung externe Ereignisse auslöst. So zählt der Zähler im Modus 0 vom angegebenen Startwert bis 0 herunter (838 ns) pro Schritt und setzt am Ende die OUTx Leitung auf 1. Um periodische Impulse zu erzeugen, eignet sich am besten Modus 2. Dabei wird bei Erreichen des Wertes 0 ein kurzer Impuls auf OUTx ausgegeben und der Zähler wird automatisch wieder mit dem Startwert initialisiert, worauf der Vorgang wieder von vorn losgeht.

Zur Einstellung eines 16 Bit Zählerwertes sind damit drei out-Befehle notwendig. Der erste zum Übergeben des Steuerwortes und zwei weitere mit dem nieder- und dem höherwertigen Byte des Zählerwertes.

-------------------------------------------------------------------------------------------------------------
Was ist ein Interrupt?

- asynchrone Unterbrechungen
– die (eigentlichen) Unterbrechungen (Interrupts)
- werden von Geräten(Hardware) ausgelöst
- sind ein Mechanismus, um von der Hardware aus den Aufruf von Programmen zu veranlassen
- Interrupts dienen als Brücke zwischen Hard- und Software
- damit Geräte mit ihren Steuerprogrammen (Gerätetreibern) kommunizieren können
– um Anfänge/Beendigungen/Fehler von Geräteoperationen anzuzeigen
– um Datentransfers durch den Treiber zu initiieren
– oder generell Unterstützung durch den Treiber anzufordern
- Interrupts können prinzipiell jederzeit auftreten
- Parallel zur CPU agierende Geräte sind die Verursacher
- sind nicht vorhersagbar für die CPU


-------------------------------------------------------------------------------------------------------------
Wie kann die CPU Interrupts unterscheiden?

- Vectortabelle, enthält eindeutig identifizierbare Behandlungsroutinen 
- Interrupt (hat ID)
- CPU ruft Vektortabelle auf
- in VTable sind die Events (Behandlungsroutine) mit ID aufgerufen
- EventID wird abgeglichen mit Interrupt ID
- Behandlungsroutine wird aufgerufen
- Eventcoupler (packt Interrupt und Behandlungsroutine zusammen, schiebt die ID ins eax Register) und ruft Guardian auf (koppeln)
- Guardian (Torwächter) greift auf Platte, Terminal und Uhr zu


-------------------------------------------------------------------------------------------------------------
Wie werden Interrupts behandelt?

Innerhalb einer Unterbrechungsroutine geschieht normalerweise folgendes:
- Weitere Interrupts verhindern.
- Sichern des Prozessorzustandes
- Register werden auf Stack gesichert
- Wiederherstellen des Prozessorzustandes
- Interrupts wieder zulassen
- Rücksprung in das unterbrochene Programm


-------------------------------------------------------------------------------------------------------------
Können neue Interrupts während einer Interruptsbehandlung auftreten?

Betriebssystemabhängig



-------------------------------------------------------------------------------------------------------------
Wenn ja, werden diese dann umgehend behandelt?

- Wenn im Systemmodus gerade Interrupt behandelt wird und neues Interrupt kommt, wird aktuelles unterbrochen und das neue Interrupt sofort behandelt (Abhängig vom BS siehe vorherige Frage)


-------------------------------------------------------------------------------------------------------------
Wenn nein, werden die blockierten Interrupts durch das Gerät später nochmal ausgelöst?

Abhängig vom BS


-------------------------------------------------------------------------------------------------------------
Zwei Prozesse A und B sollen in einer Endlosschleife immer wieder ihren Namen ausgeben.
Diese Ausgabe dauert 10 Takte. Wenn Prozess A eine Zeitscheibe von 10 Takten und
Prozess B eine Zeitscheibe von 100 Takten zugewiesen wird, welche Ausgaben sind zu
erwarten?

A = Anton
B = Berta

Anton
Berta 10x
Anton
Berta 10x
...
